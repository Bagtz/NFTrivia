// src/index.ts
import {
  decodeAbiParameters,
  encodeFunctionData,
  erc20Abi,
  erc721Abi,
  getAddress as getAddress2,
  hexToBigInt,
  hexToBool,
  parseAbi,
  parseAbiParameters,
  slice
} from "viem";

// src/wallet.ts
import { getAddress, isAddress } from "viem";

// src/rollups.ts
var dAppAddressRelayAddress = "0xF5DE34d6BbC0446E2a45719E718efEbaaE179daE";
var erc1155BatchPortalAddress = "0xedB53860A6B52bbb7561Ad596416ee9965B055Aa";
var erc1155SinglePortalAddress = "0x7CFB0193Ca87eB6e48056885E026552c3A941FC4";
var erc20PortalAddress = "0x9C21AEb2093C32DDbC53eEF24B873BDCd1aDa1DB";
var erc721PortalAddress = "0x237F8DD094C0e47f4236f12b4Fa01d6Dae89fb87";
var etherPortalAddress = "0xFfdbe43d4c855BF7e0f105c400A50857f53AB044";

// src/wallet.ts
var createEmptyWallet = () => ({
  ether: 0n,
  erc20: {},
  erc721: {},
  erc1155: {}
});
var normalizeAddress = (address) => isAddress(address) ? getAddress(address) : address;
var WalletAppImpl = class {
  dapp;
  wallets = {};
  constructor() {
    this.handler = this.handler.bind(this);
  }
  etherBalanceOf(address) {
    address = normalizeAddress(address);
    const wallet = this.wallets[address] ?? createEmptyWallet();
    return wallet.ether;
  }
  erc20BalanceOf(token, address) {
    if (isAddress(address)) {
      address = getAddress(address);
    }
    const wallet = this.wallets[address] ?? createEmptyWallet();
    return wallet.erc20[token] ?? 0n;
  }
  erc721Has(token, address, tokenId) {
    address = normalizeAddress(address);
    const wallet = this.wallets[address] ?? createEmptyWallet();
    const ids = wallet.erc721[token] ?? /* @__PURE__ */ new Set();
    return ids.has(tokenId);
  }
  erc1155BalanceOf(token, address, tokenId) {
    address = normalizeAddress(address);
    const wallet = this.wallets[address] ?? createEmptyWallet();
    const values = wallet.erc1155[token] ?? /* @__PURE__ */ new Map();
    return values.get(tokenId) ?? 0n;
  }
  getWallet(address) {
    address = normalizeAddress(address);
    const wallet = this.wallets[address] ?? createEmptyWallet();
    return wallet;
  }
  handler = async (data) => {
    if (isEtherDeposit(data)) {
      let { sender, value } = parseEtherDeposit(data.payload);
      const wallet = this.wallets[sender] ?? createEmptyWallet();
      wallet.ether += value;
      this.wallets[sender] = wallet;
      return "accept";
    } else if (isERC20Deposit(data)) {
      let { success, token, sender, amount } = parseERC20Deposit(
        data.payload
      );
      if (success) {
        const wallet = this.wallets[sender] ?? createEmptyWallet();
        wallet.erc20[token] = wallet.erc20[token] ? wallet.erc20[token] + amount : amount;
        this.wallets[sender] = wallet;
      }
      return "accept";
    } else if (isERC721Deposit(data)) {
      const { sender, token, tokenId } = parseERC721Deposit(data.payload);
      const wallet = this.wallets[sender] ?? createEmptyWallet();
      wallet.erc721[token] = wallet.erc721[token] ?? /* @__PURE__ */ new Set();
      wallet.erc721[token].add(tokenId);
      this.wallets[sender] = wallet;
      return "accept";
    } else if (isERC1155SingleDeposit(data)) {
      const { sender, token, tokenId, value } = parseERC1155SingleDeposit(
        data.payload
      );
      const wallet = this.wallets[sender] ?? createEmptyWallet();
      wallet.erc1155[token] = wallet.erc1155[token] ?? /* @__PURE__ */ new Map();
      wallet.erc1155[token].set(
        tokenId,
        (wallet.erc1155[token].get(tokenId) ?? 0n) + value
      );
      this.wallets[sender] = wallet;
      return "accept";
    } else if (isERC1155BatchDeposit(data)) {
      const { sender, token, tokenIds, values } = parseERC1155BatchDeposit(data.payload);
      const wallet = this.wallets[sender] ?? createEmptyWallet();
      wallet.erc1155[token] = wallet.erc1155[token] ?? /* @__PURE__ */ new Map();
      tokenIds.forEach((tokenId, i) => {
        wallet.erc1155[token].set(
          tokenId,
          (wallet.erc1155[token].get(tokenId) ?? 0n) + values[i]
        );
      });
      this.wallets[sender] = wallet;
      return "accept";
    } else if (getAddress(data.metadata.msg_sender) === dAppAddressRelayAddress) {
      this.dapp = getAddress(data.payload);
      return "accept";
    }
    return "reject";
  };
  transferEther(from, to, value) {
    from = normalizeAddress(from);
    to = normalizeAddress(to);
    const balance = this.etherBalanceOf(from);
    if (balance < value) {
      throw new Error(`insufficient balance of user ${from}`);
    }
    const walletFrom = this.wallets[from] ?? createEmptyWallet();
    const walletTo = this.wallets[to] ?? createEmptyWallet();
    walletFrom.ether = walletFrom.ether - value;
    walletTo.ether = walletTo.ether + value;
    this.wallets[from] = walletFrom;
    this.wallets[to] = walletTo;
  }
  transferERC20(token, from, to, amount) {
    from = normalizeAddress(from);
    to = normalizeAddress(to);
    const balance = this.erc20BalanceOf(token, from);
    if (balance < amount) {
      throw new Error(
        `insufficient balance of user ${from} of token ${token}`
      );
    }
    const walletFrom = this.wallets[from] ?? createEmptyWallet();
    const walletTo = this.wallets[to] ?? createEmptyWallet();
    walletFrom.erc20[token] = walletFrom.erc20[token] - amount;
    walletTo.erc20[token] = walletTo.erc20[token] ? walletTo.erc20[token] + amount : amount;
    this.wallets[from] = walletFrom;
    this.wallets[to] = walletTo;
  }
  transferERC721(token, from, to, tokenId) {
    from = normalizeAddress(from);
    to = normalizeAddress(to);
    const has = this.erc721Has(token, from, tokenId);
    if (!has) {
      throw new Error(
        `user ${from} does not have tokenId ${tokenId} of token ${token}`
      );
    }
    const walletFrom = this.wallets[from] ?? createEmptyWallet();
    const walletTo = this.wallets[to] ?? createEmptyWallet();
    walletFrom.erc721[token].delete(tokenId);
    walletTo.erc721[token] = walletTo.erc721[token] ? walletTo.erc721[token].add(tokenId) : /* @__PURE__ */ new Set([tokenId]);
    this.wallets[from] = walletFrom;
    this.wallets[to] = walletTo;
  }
  transferERC1155(token, from, to, tokenId, value) {
    from = normalizeAddress(from);
    to = normalizeAddress(to);
    const balance = this.erc1155BalanceOf(token, from, tokenId);
    if (balance < value) {
      throw new Error(
        `insufficient balance of user ${from} of token ${token} tokenId ${tokenId}`
      );
    }
    const walletFrom = this.wallets[from] ?? createEmptyWallet();
    const walletTo = this.wallets[to] ?? createEmptyWallet();
    const tokenBalance = this.wallets[from].erc1155[token].get(tokenId) ?? 0n;
    walletFrom.erc1155[token].set(tokenId, tokenBalance - value);
    walletTo.erc1155[token] = walletTo.erc1155[token] ?? /* @__PURE__ */ new Map();
    walletTo.erc1155[token].set(
      tokenId,
      (walletTo.erc1155[token].get(tokenId) ?? 0n) + value
    );
    this.wallets[from] = walletFrom;
    this.wallets[to] = walletTo;
  }
  transferBatchERC1155(token, from, to, tokenIds, values) {
    from = normalizeAddress(from);
    to = normalizeAddress(to);
    if (tokenIds.length !== values.length) {
      throw new Error(
        `tokenIds and values must have the same length: ${tokenIds.length} != ${values.length}`
      );
    }
    tokenIds.forEach((tokenId, i) => {
      const balance = this.erc1155BalanceOf(token, from, tokenId);
      const value = values[i];
      if (balance < value) {
        throw new Error(
          `insufficient balance of user ${from} of token ${token} tokenId ${tokenId}`
        );
      }
    });
    const walletFrom = this.wallets[from] ?? createEmptyWallet();
    const walletTo = this.wallets[to] ?? createEmptyWallet();
    tokenIds.forEach((tokenId, i) => {
      const tokenBalance = this.wallets[from].erc1155[token].get(tokenId) ?? 0n;
      const value = values[i];
      walletFrom.erc1155[token].set(tokenId, tokenBalance - value);
      walletTo.erc1155[token] = walletTo.erc1155[token] ?? /* @__PURE__ */ new Map();
      walletTo.erc1155[token].set(
        tokenId,
        (walletTo.erc1155[token].get(tokenId) ?? 0n) + value
      );
    });
    this.wallets[from] = walletFrom;
    this.wallets[to] = walletTo;
  }
  withdrawEther(address, value) {
    address = getAddress(address);
    const balance = this.etherBalanceOf(address);
    if (this.etherBalanceOf(address) < value) {
      throw new Error(
        `insufficient balance of user ${address}: ${value.toString()} > ${balance.toString()}`
      );
    }
    if (!this.dapp) {
      throw new Error(`undefined application address`);
    }
    const wallet = this.wallets[address];
    wallet.ether = wallet.ether - value;
    return createWithdrawEtherVoucher(this.dapp, address, value);
  }
  withdrawERC20(token, address, amount) {
    token = getAddress(token);
    address = getAddress(address);
    const balance = this.erc20BalanceOf(token, address);
    if (balance < amount) {
      throw new Error(
        `insufficient balance of user ${address} of token ${token}: ${amount.toString()} > ${balance.toString()}`
      );
    }
    const wallet = this.wallets[address];
    wallet.erc20[token] -= amount;
    return createERC20TransferVoucher(token, address, amount);
  }
  withdrawERC721(token, address, tokenId) {
    token = getAddress(token);
    address = getAddress(address);
    const has = this.erc721Has(token, address, tokenId);
    if (!has) {
      throw new Error(
        `user ${address} does not have tokenId ${tokenId} of token ${token}`
      );
    }
    if (!this.dapp) {
      throw new Error(`undefined application address`);
    }
    const wallet = this.wallets[address];
    wallet.erc721[token].delete(tokenId);
    return createERC721TransferVoucher(token, this.dapp, address, tokenId);
  }
  withdrawERC1155(token, address, tokenId, value, data) {
    token = getAddress(token);
    address = getAddress(address);
    const balance = this.erc1155BalanceOf(token, address, tokenId);
    if (balance < value) {
      throw new Error(
        `insufficient balance of user ${address} of token ${token} tokenId ${tokenId}`
      );
    }
    if (!this.dapp) {
      throw new Error(`undefined application address`);
    }
    const wallet = this.wallets[address];
    wallet.erc1155[token].set(tokenId, balance - value);
    return createERC1155SingleTransferVoucher(
      token,
      this.dapp,
      address,
      tokenId,
      value,
      data
    );
  }
  withdrawBatchERC1155(token, address, tokenIds, values, data) {
    token = getAddress(token);
    address = getAddress(address);
    if (tokenIds.length !== values.length) {
      throw new Error(
        `tokenIds and values must have the same length: ${tokenIds.length} != ${values.length}`
      );
    }
    tokenIds.forEach((tokenId, i) => {
      const balance = this.erc1155BalanceOf(token, address, tokenId);
      const value = values[i];
      if (balance < value) {
        throw new Error(
          `insufficient balance of user ${address} of token ${token} tokenId ${tokenId}`
        );
      }
    });
    if (!this.dapp) {
      throw new Error(`undefined application address`);
    }
    const wallet = this.wallets[address];
    tokenIds.forEach((tokenId, i) => {
      const balance = this.erc1155BalanceOf(token, address, tokenId);
      const value = values[i];
      wallet.erc1155[token].set(tokenId, balance - value);
    });
    return createERC1155BatchTransferVoucher(
      token,
      this.dapp,
      address,
      tokenIds,
      values,
      data
    );
  }
};

// src/abi/index.ts
var erc1155Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var cartesiDAppAbi = [
  {
    inputs: [
      {
        internalType: "contract IConsensus",
        name: "_consensus",
        type: "address"
      },
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_templateHash",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "EtherTransferFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "IncorrectEpochHash",
    type: "error"
  },
  {
    inputs: [],
    name: "IncorrectOutputHashesRootHash",
    type: "error"
  },
  {
    inputs: [],
    name: "IncorrectOutputsEpochRootHash",
    type: "error"
  },
  {
    inputs: [],
    name: "InputIndexOutOfClaimBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyDApp",
    type: "error"
  },
  {
    inputs: [],
    name: "VoucherReexecutionNotAllowed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract IConsensus",
        name: "newConsensus",
        type: "address"
      }
    ],
    name: "NewConsensus",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "voucherId",
        type: "uint256"
      }
    ],
    name: "VoucherExecuted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_destination",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_payload",
        type: "bytes"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "uint64",
                name: "inputIndexWithinEpoch",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "outputIndexWithinInput",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "outputHashesRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "vouchersEpochRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "noticesEpochRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "machineStateHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32[]",
                name: "outputHashInOutputHashesSiblings",
                type: "bytes32[]"
              },
              {
                internalType: "bytes32[]",
                name: "outputHashesInEpochSiblings",
                type: "bytes32[]"
              }
            ],
            internalType: "struct OutputValidityProof",
            name: "validity",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          }
        ],
        internalType: "struct Proof",
        name: "_proof",
        type: "tuple"
      }
    ],
    name: "executeVoucher",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getConsensus",
    outputs: [
      {
        internalType: "contract IConsensus",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTemplateHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IConsensus",
        name: "_newConsensus",
        type: "address"
      }
    ],
    name: "migrateToConsensus",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    name: "onERC1155BatchReceived",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    name: "onERC1155Received",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    name: "onERC721Received",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_notice",
        type: "bytes"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "uint64",
                name: "inputIndexWithinEpoch",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "outputIndexWithinInput",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "outputHashesRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "vouchersEpochRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "noticesEpochRootHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "machineStateHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32[]",
                name: "outputHashInOutputHashesSiblings",
                type: "bytes32[]"
              },
              {
                internalType: "bytes32[]",
                name: "outputHashesInEpochSiblings",
                type: "bytes32[]"
              }
            ],
            internalType: "struct OutputValidityProof",
            name: "validity",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "context",
            type: "bytes"
          }
        ],
        internalType: "struct Proof",
        name: "_proof",
        type: "tuple"
      }
    ],
    name: "validateNotice",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_inputIndex",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_outputIndexWithinInput",
        type: "uint256"
      }
    ],
    name: "wasVoucherExecuted",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    name: "withdrawEther",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/index.ts
var WalletABI = parseAbi([
  "function withdrawEther(uint256 value)",
  "function withdrawERC20(address token, uint256 amount)",
  "function withdrawERC721(address token, uint256 tokenId)",
  "function withdrawERC1155(address token, uint256 tokenId, uint256 value)",
  "function withdrawERC1155Batch(address token, uint256[] tokenIds, uint256[] values)"
]);
var createWallet = () => {
  return new WalletAppImpl();
};
var parseEtherDeposit = (payload) => {
  const sender = getAddress2(slice(payload, 0, 20));
  const value = hexToBigInt(slice(payload, 20, 52), { size: 32 });
  return { sender, value };
};
var parseERC20Deposit = (payload) => {
  const success = hexToBool(slice(payload, 0, 1));
  const token = getAddress2(slice(payload, 1, 21));
  const sender = getAddress2(slice(payload, 21, 41));
  const amount = hexToBigInt(slice(payload, 41, 73), { size: 32 });
  return { success, token, sender, amount };
};
var parseERC721Deposit = (payload) => {
  const token = getAddress2(slice(payload, 0, 20));
  const sender = getAddress2(slice(payload, 20, 40));
  const tokenId = hexToBigInt(slice(payload, 40, 72), { size: 32 });
  return {
    token,
    sender,
    tokenId
  };
};
var parseERC1155SingleDeposit = (payload) => {
  const token = getAddress2(slice(payload, 0, 20));
  const sender = getAddress2(slice(payload, 20, 40));
  const tokenId = hexToBigInt(slice(payload, 40, 72), { size: 32 });
  const value = hexToBigInt(slice(payload, 72, 104), { size: 32 });
  return {
    token,
    sender,
    tokenId,
    value
  };
};
var parseERC1155BatchDeposit = (payload) => {
  const token = getAddress2(slice(payload, 0, 20));
  const sender = getAddress2(slice(payload, 20, 40));
  const rest = slice(payload, 40);
  const [tokenIds, values] = decodeAbiParameters(
    parseAbiParameters("uint256[] tokenIds, uint256[] values"),
    rest
  );
  return { token, sender, tokenIds, values };
};
var isEtherDeposit = (data) => getAddress2(data.metadata.msg_sender) === etherPortalAddress;
var isERC20Deposit = (data) => getAddress2(data.metadata.msg_sender) === erc20PortalAddress;
var isERC721Deposit = (data) => getAddress2(data.metadata.msg_sender) === erc721PortalAddress;
var isERC1155SingleDeposit = (data) => getAddress2(data.metadata.msg_sender) === erc1155SinglePortalAddress;
var isERC1155BatchDeposit = (data) => getAddress2(data.metadata.msg_sender) === erc1155BatchPortalAddress;
var createWithdrawEtherVoucher = (application, receiver, value) => {
  const call = encodeFunctionData({
    abi: cartesiDAppAbi,
    functionName: "withdrawEther",
    args: [receiver, value]
  });
  return {
    destination: application,
    // application Address
    payload: call
  };
};
var createERC20TransferVoucher = (token, recipient, amount) => {
  const call = encodeFunctionData({
    abi: erc20Abi,
    functionName: "transfer",
    args: [recipient, amount]
  });
  return {
    destination: token,
    payload: call
  };
};
var createERC721TransferVoucher = (token, from, to, tokenId) => {
  const call = encodeFunctionData({
    abi: erc721Abi,
    functionName: "safeTransferFrom",
    args: [from, to, tokenId]
  });
  return {
    destination: token,
    payload: call
  };
};
var createERC1155SingleTransferVoucher = (token, from, to, tokenId, value, data) => {
  const call = encodeFunctionData({
    abi: erc1155Abi,
    functionName: "safeTransferFrom",
    args: [from, to, tokenId, value, data]
  });
  return {
    destination: token,
    payload: call
  };
};
var createERC1155BatchTransferVoucher = (token, from, to, tokenIds, values, data) => {
  const call = encodeFunctionData({
    abi: erc1155Abi,
    functionName: "safeBatchTransferFrom",
    args: [from, to, tokenIds, values, data]
  });
  return {
    destination: token,
    payload: call
  };
};
export {
  WalletABI,
  createERC1155BatchTransferVoucher,
  createERC1155SingleTransferVoucher,
  createERC20TransferVoucher,
  createERC721TransferVoucher,
  createWallet,
  createWithdrawEtherVoucher,
  isERC1155BatchDeposit,
  isERC1155SingleDeposit,
  isERC20Deposit,
  isERC721Deposit,
  isEtherDeposit,
  parseERC1155BatchDeposit,
  parseERC1155SingleDeposit,
  parseERC20Deposit,
  parseERC721Deposit,
  parseEtherDeposit
};
