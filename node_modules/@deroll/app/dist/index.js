"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createApp: () => createApp
});
module.exports = __toCommonJS(src_exports);

// src/app.ts
var import_openapi_fetch = __toESM(require("openapi-fetch"));
var HttpApp = class {
  options;
  advanceHandlers;
  inspectHandlers;
  POST;
  constructor(options) {
    this.options = options;
    this.advanceHandlers = [];
    this.inspectHandlers = [];
    const { POST } = (0, import_openapi_fetch.default)({ baseUrl: options.url });
    this.POST = POST;
  }
  async createNotice(notice) {
    const { data, response } = await this.POST("/notice", {
      body: notice
    });
    if (data) {
      return data.index;
    } else {
      throw new Error(response.statusText);
    }
  }
  async createReport(report) {
    const { response } = await this.POST("/report", {
      body: report
    });
    if (!response.ok) {
      throw new Error(response.statusText);
    }
  }
  async createVoucher(voucher) {
    const { data, response } = await this.POST("/voucher", {
      body: voucher
    });
    if (data) {
      return data.index;
    } else {
      throw new Error(response.statusText);
    }
  }
  handleAdvance = async (data) => {
    let finalResult = "reject";
    for (const handler of this.advanceHandlers) {
      try {
        const result = await handler(data);
        if (result == "accept") {
          if (!this.options.broadcastAdvanceRequests) {
            return result;
          }
          finalResult = result;
        }
      } catch (e) {
        console.error(e);
      }
    }
    return finalResult;
  };
  handleInspect = async (data) => {
    for (const handler of this.inspectHandlers) {
      try {
        await handler(data);
      } catch (e) {
        console.error(e);
      }
    }
  };
  addAdvanceHandler(handler) {
    this.advanceHandlers.push(handler);
  }
  addInspectHandler(handler) {
    this.inspectHandlers.push(handler);
  }
  async start() {
    let status = "accept";
    while (true) {
      const { data, response } = await this.POST("/finish", {
        body: { status },
        parseAs: "text"
      });
      if (response.status == 200 && data) {
        const request = JSON.parse(data);
        switch (request.request_type) {
          case "advance_state":
            status = await this.handleAdvance(
              request.data
            );
            break;
          case "inspect_state":
            await this.handleInspect(
              request.data
            );
            break;
        }
      } else if (response.status == 202) {
      }
    }
  }
};

// src/index.ts
var createApp = (options) => {
  return new HttpApp(options);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createApp
});
